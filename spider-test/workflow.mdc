# 智能需求收集与设计工作流

## 工作流状态管理
### 状态指示器
- 在每个阶段显示当前进度：`[需求收集] → [设计文档] → [实现计划] → [任务完成]`
- 提供阶段间的快速跳转和回退机制
- 支持工作流暂停和恢复功能

### 进度可视化
- 显示当前阶段完成百分比
- 标识阻塞点和风险项
- 提供时间估算和实际耗时对比

## 异常处理机制
### 回退策略
- 当需求收集失败时，提供简化需求模板作为回退方案
- 设计阶段遇到技术障碍时，提供替代技术方案或降低复杂度选项
- 实现计划调整的触发条件和自动提醒机制

### 风险识别
- 在每个阶段识别潜在风险点
- 提供风险缓解策略
- 设置风险升级机制

## 上下文感知阶段
在开始需求收集前，模型应该：
- 分析现有项目结构和代码库
- 识别已实现的功能和待开发功能
- 了解项目的技术栈和架构模式
- 检查现有的规范文档结构
- 识别技术债务和重构机会
- 评估项目当前状态和资源约束

## 需求收集阶段 (Requirements Gathering)
基于用户的功能想法，生成EARS格式的初始需求文档，然后与用户迭代完善。

### 约束条件：
- 模型必须创建 `./specs/{feature_name}/requirements.md` 文件（如果不存在）
- 模型必须基于用户的粗略想法生成初始需求文档，无需先询问连续问题
- 模型必须格式化初始requirements.md文档，包含：
  - 清晰的功能概述部分
  - 分层编号的需求列表，每个需求包含：
    - 用户故事格式："作为[角色]，我想要[功能]，以便[收益]"
    - EARS格式的验收标准编号列表
- 模型应该考虑边界情况、用户体验、技术约束和成功标准
- 模型应该参考现有项目的架构模式和设计原则
- 模型应该识别与现有功能的集成点

### 需求优先级管理
- 使用 MoSCoW 方法对需求进行分类：
  - **Must-have**：核心功能，项目成功必须包含
  - **Should-have**：重要功能，应该包含但可以延迟
  - **Could-have**：可选功能，如果时间允许则包含
  - **Won't-have**：当前版本不包含的功能
- 识别需求间的依赖关系和冲突
- 提供需求冲突检测和解决机制

### 需求验证清单
模型必须在需求文档中包含以下验证项：
- [ ] 功能需求是否明确且可测试？
- [ ] 非功能需求是否量化（性能、安全、可用性）？
- [ ] 用户故事是否包含完整的验收标准？
- [ ] 是否考虑了边界情况和异常处理？
- [ ] 是否识别了技术约束和限制？
- [ ] 是否评估了实现复杂度和风险？
- [ ] 是否考虑了与现有功能的集成点？

### 快速反馈检查点
- 在需求收集过程中设置检查点，验证需求的完整性和一致性
- 提供早期风险识别和复杂度评估
- 支持快速原型验证关键需求

### 迭代流程：
- 更新需求文档后，模型必须询问用户"需求看起来如何？如果满意，我们可以进入设计阶段。"
- 使用 'userInput' 工具，原因字符串为 'spec-requirements-review'
- 如果用户要求修改或未明确批准，模型必须修改需求文档
- 每次迭代后必须请求明确批准
- 在收到明确批准前不得进入设计文档阶段
- 必须继续反馈-修订循环直到收到明确批准

## 设计文档创建阶段 (Design Document Creation)
用户批准需求后，基于功能需求开发全面的设计文档，在设计过程中进行必要的研究。

### 约束条件：
- 模型必须创建 `./specs/{feature_name}/design.md` 文件（如果不存在）
- 模型必须基于功能需求识别需要研究的领域
- 模型必须进行研究并在对话线程中建立上下文
- 模型不应该创建单独的研究文件，而是将研究作为设计和实现计划的上下文
- 模型必须总结将影响功能设计的关键发现
- 模型应该引用来源并在对话中包含相关链接
- 模型必须在 `./specs/{feature_name}/design.md` 创建详细的设计文档
- 模型必须将研究发现直接纳入设计过程
- 模型必须包含以下部分：
  - 概述
  - 架构
  - 组件和接口
  - 数据模型
  - 错误处理
  - 测试策略
- 模型应该包含图表或视觉表示（如适用，使用Mermaid图表）
- 模型必须确保设计解决澄清过程中识别的所有功能需求
- 模型应该突出设计决策及其理由
- 模型可以在设计过程中询问用户对特定技术决策的输入

### 设计决策记录 (ADR)
模型必须记录关键设计决策，包括：
- 决策的背景和上下文
- 考虑的替代方案
- 选择特定方案的理由
- 决策的影响和风险
- 决策的日期和负责人

### 技术调研框架
模型必须进行系统性的技术调研：
- 明确调研范围和深度要求
- 提供调研结果评估标准
- 要求调研结论的可操作性和可验证性
- 记录调研过程中的关键发现和限制

### 变更影响分析
- 评估设计变更对现有功能的影响
- 提供变更成本估算和风险评估
- 记录变更理由和预期收益
- 识别变更的连锁反应和依赖关系

### 迭代流程：
- 更新设计文档后，模型必须询问用户"设计看起来如何？如果满意，我们可以进入实现计划。"
- 使用 'userInput' 工具，原因字符串为 'spec-design-review'
- 如果用户要求修改或未明确批准，模型必须修改设计文档
- 每次迭代后必须请求明确批准
- 在收到明确批准前不得进入实现计划
- 必须继续反馈-修订循环直到收到明确批准
- 模型必须将所有用户反馈纳入设计文档后再继续
- 如果在设计过程中发现差距，模型必须提供返回功能需求澄清的选项

## 实现计划阶段 (Implementation Planning)
用户批准设计后，基于需求和设计创建可操作的实现计划，包含编码任务清单。

### 约束条件：
- 模型必须创建 `./specs/{feature_name}/tasks.md` 文件（如果不存在）
- 如果用户表示需要对设计进行任何更改，模型必须返回设计步骤
- 如果用户表示我们需要额外的需求，模型必须返回需求步骤
- 模型必须在 `./specs/{feature_name}/tasks.md` 创建实现计划
- 模型必须使用以下具体指令创建实现计划：将功能设计转换为代码生成LLM的一系列提示，以测试驱动的方式实现每个步骤。优先考虑最佳实践、增量进度和早期测试，确保在任何阶段都没有复杂性的巨大跳跃。确保每个提示都建立在之前的提示基础上，并以连接事物结束。不应该有悬空或孤立的代码没有集成到前一个步骤中。仅专注于涉及编写、修改或测试代码的任务。

### 格式要求：
- 模型必须将实现计划格式化为编号的复选框列表，最多两级层次结构：
  - 顶级项目（如史诗）仅在需要时使用
  - 子任务应使用小数点表示法编号（例如1.1、1.2、2.1）
- 每个项目必须是复选框
- 优先简单结构

### 任务估算和依赖关系
- 每个任务必须包含时间估算（小时/天）
- 识别任务间的依赖关系和关键路径
- 提供任务优先级排序
- 考虑资源约束和并行开发机会

### 任务要求：
- 模型必须确保每个任务项目包括：
  - 涉及编写、修改或测试代码的明确目标作为任务描述
  - 任务下的附加信息作为子项目
  - 对需求文档中特定需求的引用（引用细粒度子需求，而不仅仅是用户故事）
  - 任务的时间估算和依赖关系
- 模型必须确保实现计划是一系列离散的、可管理的编码步骤
- 模型必须确保每个任务引用需求文档中的特定需求
- 模型不得包含设计文档中已涵盖的过多实现细节
- 模型必须假设所有上下文文档（功能需求、设计）在实现期间都可用
- 模型必须确保每个步骤都增量地建立在之前的步骤基础上
- 模型应该优先考虑测试驱动开发（如适用）
- 模型必须确保计划涵盖可以通过代码实现的设计的所有方面
- 模型应该排序步骤以通过代码早期验证核心功能
- 模型必须确保所有需求都通过实现任务涵盖
- 如果在实现计划过程中发现差距，模型必须提供返回前一步骤（需求或设计）的选项

### 任务范围：
- 模型必须仅包含可以由编码代理执行的任务（编写代码、创建测试等）
- 模型必须包含集成测试用例开发和测试埋点实现
- 模型必须确保任务同时通过构建和开发环境测试
- 模型必须专注于可以在开发环境中执行的代码实现任务
- 模型必须确保每个任务对编码代理都是可操作的，遵循以下指导原则：
  - 任务应该涉及编写、修改或测试特定的代码组件
  - 任务应该指定需要创建或修改的文件或组件
  - 任务应该足够具体，编码代理可以在没有额外澄清的情况下执行
  - 任务应该专注于实现细节而不是高级概念
  - 任务应该范围限定为特定的编码活动（例如"实现X函数"而不是"支持X功能"）
  - 任务必须包含相应的测试用例和测试埋点
  - 任务必须验证在构建和开发环境中的兼容性

### 排除任务类型：
模型必须明确避免在实现计划中包含以下类型的非编码任务：
- 用户验收测试或用户反馈收集
- 部署到生产或暂存环境
- 性能指标收集或分析（但必须包含开发测试埋点）
- 运行应用程序测试端到端流程（但我们必须编写自动化测试从用户角度测试端到端）
- 用户培训或文档创建
- 业务流程变更或组织变更
- 营销或沟通活动
- 任何无法通过编写、修改或测试代码完成的任务

### 测试策略细化
模型必须在每个任务中包含以下测试相关要求：

#### 1. 单元测试要求
- 每个功能模块必须有对应的单元测试
- 测试覆盖率必须达到≥80%
- 必须包含边界条件和错误情况测试
- 测试文件命名规范：`*.test.ts` 或 `*.spec.ts`
- 必须包含性能基准测试
- 必须测试异常处理和错误恢复

#### 2. 集成测试要求
- 每个API端点必须有集成测试
- 必须测试组件间的交互
- 必须包含数据库集成测试
- 必须测试外部服务集成（如WebSocket、文件上传等）
- 必须测试数据流和状态管理
- 必须包含并发和竞态条件测试

#### 3. 端到端测试要求
- 关键用户流程必须有E2E测试
- 必须测试完整的用户操作流程
- 必须包含跨浏览器兼容性测试
- 必须测试响应式设计在不同设备上的表现
- 必须测试离线功能和错误恢复
- 必须包含性能测试和负载测试

#### 4. 测试埋点要求
- 必须实现开发测试埋点用于性能监控
- 必须记录关键操作的执行时间
- 必须监控内存使用和资源消耗
- 必须记录错误和异常情况
- 必须包含用户行为分析埋点
- 必须实现错误追踪和日志记录

#### 5. 环境测试要求
- 必须验证在开发环境中的功能
- 必须验证在构建环境中的功能
- 必须确保代码在两种环境中的兼容性
- 必须测试环境特定的配置和依赖
- 必须测试不同网络条件下的表现
- 必须验证部署和回滚流程

#### 6. 安全测试要求
- 必须包含输入验证和输出编码测试
- 必须测试认证和授权机制
- 必须验证数据隐私和合规要求
- 必须测试常见的Web安全漏洞
- 必须包含渗透测试和漏洞扫描

### 自动化质量门禁
- 代码覆盖率检查（≥80%）
- 类型安全检查（TypeScript严格模式）
- 性能基准检查（Core Web Vitals）
- 安全扫描集成（OWASP Top 10）
- 代码规范检查（ESLint + Prettier）
- 依赖安全扫描

### 迭代流程：
- 更新任务文档后，模型必须询问用户"任务看起来如何？"
- 使用 'userInput' 工具，原因字符串为 'spec-tasks-review'
- 如果用户要求修改或未明确批准，模型必须修改任务文档
- 每次迭代后必须请求明确批准
- 在收到明确批准前不得考虑工作流完成
- 必须继续反馈-修订循环直到收到明确批准
- 任务文档获得批准后，模型必须停止

### 工作流限制：
- 此工作流仅用于创建设计和规划工件。功能的实际实现应该通过单独的工作流完成
- 模型不得尝试作为此工作流的一部分实现功能
- 一旦设计 and 规划工件创建完成，模型必须清楚地与用户沟通此工作流已完成
- 模型必须告知用户，他们可以通过打开tasks.md文件并点击任务项目旁边的"开始任务"来开始执行任务

## 任务完成处理阶段 (Task Completion Processing)
当用户完成某个任务后，模型应该帮助用户更新任务状态、记录变更日志，并生成友好的changelog。

### 约束条件：
- 模型必须更新 `./specs/{feature_name}/tasks.md` 文件中对应任务的完成状态
- 模型必须创建或更新 `./specs/{feature_name}/changelog.md` 文件
- 模型必须生成对大模型和人类都友好的changelog格式
- 模型必须记录具体的实现细节和变更内容
- 模型必须包含相关的文件路径和代码变更信息

### 任务状态更新：
- 将完成的任务标记为 `[x]`（已完成）
- 在任务下方添加完成时间戳
- 记录实际完成的工作内容
- 添加相关的文件路径和代码变更
- 记录实际耗时与估算的对比
- 记录遇到的问题和解决方案

### Changelog格式要求：
模型必须使用以下格式创建changelog：

```markdown
# 变更日志

## [版本号] - YYYY-MM-DD

### 新增功能
- 功能描述
  - 具体实现细节
  - 相关文件：`path/to/file.ts`
  - 测试覆盖率：XX%
  - 性能影响：无/轻微/中等/显著

### 修改功能
- 功能描述
  - 修改内容
  - 相关文件：`path/to/file.ts`
  - 向后兼容性：是/否
  - 迁移指南：如需

### 修复问题
- 问题描述
  - 修复方案
  - 相关文件：`path/to/file.ts`
  - 影响范围：局部/全局
  - 回归测试：已通过

### 技术改进
- 改进描述
  - 具体改进内容
  - 相关文件：`path/to/file.ts`
  - 性能提升：XX%
  - 代码质量：提升/保持/下降

### 文档更新
- 文档更新内容
  - 相关文件：`path/to/file.md`
  - 更新类型：新增/修改/删除

### 依赖更新
- 依赖包名称和版本
  - 更新原因：安全/功能/性能
  - 影响评估：无/轻微/中等/显著
  - 相关文件：`package.json`

### 配置变更
- 配置项名称
  - 变更内容
  - 影响范围
  - 相关文件：`config/*`
```

### Changelog内容要求：
- **对大模型友好**：
  - 使用结构化的格式
  - 包含具体的文件路径
  - 描述技术实现细节
  - 使用标准的变更类型分类
  - 包含性能指标和测试结果

- **对人类友好**：
  - 使用清晰的中文描述
  - 避免过于技术化的术语
  - 突出用户可见的功能改进
  - 包含使用示例或截图说明
  - 提供升级和迁移指南

### 变更类型分类：
1. **新增功能**：新实现的功能特性
2. **修改功能**：对现有功能的改进或调整
3. **修复问题**：bug修复和问题解决
4. **技术改进**：代码重构、性能优化等
5. **文档更新**：文档、注释、README等更新
6. **依赖更新**：第三方库版本更新
7. **配置变更**：环境配置、构建配置等变更

### 成功指标跟踪
- 功能完成度指标（计划任务完成率）
- 质量指标（缺陷密度、测试通过率）
- 性能指标（响应时间、吞吐量、Core Web Vitals）
- 用户满意度指标（可用性、易用性）
- 技术债务指标（代码复杂度、重复代码率）

### 迭代流程：
- 用户完成任务后，模型必须询问"任务已完成，是否需要更新任务状态和记录changelog？"
- 使用 'userInput' 工具，原因字符串为 'task-completion-processing'
- 如果用户同意，模型必须：
  - 更新任务状态
  - 生成changelog条目
  - 更新成功指标
  - 询问用户是否满意changelog内容
- 如果用户要求修改，模型必须根据反馈调整changelog
- 必须继续反馈-修订循环直到用户满意

## 项目特定指导

### 技术栈考虑：
- 前端：React + TypeScript + Playwright + Vite + Tailwind CSS + pnpm
- 后端：Nestjs  （mysql、redis、 minio、es、mongodb） 等合适的中间件
- 实时通信：WebSocket
- 测试：Vitest + Playwright + React Testing Library
- 测试埋点：自定义性能监控 + 错误追踪
- 部署：Docker

### 架构模式：
- 组件化设计
- 状态管理：Context API + React Query
- API设计：RESTful + WebSocket
- 数据持久化：（mysql、redis、 es、mongodb） 等合适的中间件
- 文件存储：minio

### 代码质量要求：
- TypeScript严格模式
- ESLint + Prettier代码规范
- 组件单元测试覆盖率≥80%
- API集成测试覆盖率≥60%
- 端到端测试覆盖关键用户流程
- 测试埋点覆盖率≥90%
- 构建和开发环境测试通过率100%

### 性能要求：
- 支持1000个并发用户
- 消息延迟≤1秒
- 文件上传大小限制100MB
- 响应式设计支持移动端
- Core Web Vitals 指标达标：
  - LCP (Largest Contentful Paint) ≤ 2.5s
  - FID (First Input Delay) ≤ 100ms
  - CLS (Cumulative Layout Shift) ≤ 0.1

### 安全要求：
- HTTPS加密通信
- JWT认证
- 文件类型白名单验证
- 输入验证和清理
- 访问权限控制
- 内容安全策略 (CSP)
- OWASP Top 10 防护
- 数据隐私和合规要求

### 性能监控要求
- 添加 Core Web Vitals 监控
- 实现自定义性能指标
- 提供性能基准和阈值
- 增加性能回归检测
- 监控资源使用情况
- 实现错误追踪和日志记录

### 文档要求
- API 文档自动生成
- 组件使用示例和最佳实践
- 部署和运维文档
- 故障排除指南
- 性能优化指南
- 安全最佳实践文档

### 团队协作支持
- 提供代码评审清单
- 增加知识分享机制
- 支持并行开发协调
- 提供冲突解决指导
- 建立代码规范检查
- 实现自动化测试流程

### 持续改进机制
- 工作流效率评估
- 团队反馈收集
- 最佳实践总结
- 流程优化建议
- 技术债务管理
- 性能优化跟踪

– The model MUST clearly communicate to the user that this workflow is complete once the design and planning artifacts are created

– The model MUST inform the user that they can begin executing tasks by opening the tasks.md file, and clicking "Start task" next to task items.