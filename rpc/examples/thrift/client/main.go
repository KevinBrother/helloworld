package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"time"
)

// Mock types for demonstration (would be generated by thrift)
type User struct {
	ID    int32
	Name  string
	Email string
	Age   int32
}

type GetUserRequest struct {
	ID int32
}

type GetUserResponse struct {
	User  *User
	Error string
}

type CreateUserRequest struct {
	Name  string
	Email string
	Age   int32
}

type CreateUserResponse struct {
	ID    int32
	Error string
}

type ListUsersRequest struct{}

type ListUsersResponse struct {
	Users []*User
	Error string
}

type UpdateUserRequest struct {
	ID    int32
	Name  string
	Email string
	Age   int32
}

type UpdateUserResponse struct {
	User  *User
	Error string
}

type DeleteUserRequest struct {
	ID int32
}

type DeleteUserResponse struct {
	Success bool
	Message string
}

// MockClient simulates a Thrift client for demonstration
type MockClient struct {
	users map[int32]*User
	nextID int32
}

func NewMockClient() *MockClient {
	c := &MockClient{
		users:  make(map[int32]*User),
		nextID: 1,
	}
	c.users[1] = &User{ID: 1, Name: "Alice", Email: "alice@example.com", Age: 28}
	c.users[2] = &User{ID: 2, Name: "Bob", Email: "bob@example.com", Age: 32}
	c.nextID = 3
	return c
}

func (c *MockClient) GetUser(ctx context.Context, req *GetUserRequest) (*GetUserResponse, error) {
	user, exists := c.users[req.ID]
	if !exists {
		return &GetUserResponse{Error: fmt.Sprintf("user with id %d not found", req.ID)}, nil
	}
	return &GetUserResponse{User: user}, nil
}

func (c *MockClient) CreateUser(ctx context.Context, req *CreateUserRequest) (*CreateUserResponse, error) {
	if req.Name == "" || req.Email == "" || req.Age <= 0 {
		return &CreateUserResponse{Error: "invalid input"}, nil
	}

	user := &User{
		ID:    c.nextID,
		Name:  req.Name,
		Email: req.Email,
		Age:   req.Age,
	}
	c.users[c.nextID] = user
	c.nextID++

	return &CreateUserResponse{ID: user.ID}, nil
}

func (c *MockClient) ListUsers(ctx context.Context, req *ListUsersRequest) (*ListUsersResponse, error) {
	users := make([]*User, 0, len(c.users))
	for _, user := range c.users {
		users = append(users, user)
	}
	return &ListUsersResponse{Users: users}, nil
}

func (c *MockClient) UpdateUser(ctx context.Context, req *UpdateUserRequest) (*UpdateUserResponse, error) {
	user, exists := c.users[req.ID]
	if !exists {
		return &UpdateUserResponse{Error: fmt.Sprintf("user with id %d not found", req.ID)}, nil
	}

	if req.Name != "" {
		user.Name = req.Name
	}
	if req.Email != "" {
		user.Email = req.Email
	}
	if req.Age > 0 {
		user.Age = req.Age
	}

	return &UpdateUserResponse{User: user}, nil
}

func (c *MockClient) DeleteUser(ctx context.Context, req *DeleteUserRequest) (*DeleteUserResponse, error) {
	if _, exists := c.users[req.ID]; !exists {
		return &DeleteUserResponse{
			Success: false,
			Message: fmt.Sprintf("user with id %d not found", req.ID),
		}, nil
	}

	delete(c.users, req.ID)

	return &DeleteUserResponse{
		Success: true,
		Message: "user deleted successfully",
	}, nil
}

func main() {
	// In real usage, you would create a thrift transport and protocol:
	//
	// transport, err := thrift.NewTSocket("localhost:9090")
	// if err != nil {
	//     log.Fatal(err)
	// }
	// defer transport.Close()
	//
	// protocol := thrift.NewTBinaryProtocolFactoryDefault().GetProtocol(transport)
	// client := user.NewUserServiceClientFactory(transport, protocol)
	//
	// if err := transport.Open(); err != nil {
	//     log.Fatal(err)
	// }

	// Using mock client for demonstration
	client := NewMockClient()

	log.Println("=== Thrift Client Demo (Mock) ===")
	log.Println("Note: This is a demonstration showing the client API pattern.")
	log.Println("For full Thrift support, generate code with: thrift --gen go idl/user.thrift\n")

	ctx := context.Background()

	// 1. List initial users
	fmt.Println("1. Listing initial users...")
	listResp, err := client.ListUsers(ctx, &ListUsersRequest{})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("   Total users: %d\n", len(listResp.Users))
	for _, u := range listResp.Users {
		fmt.Printf("   - ID: %d, Name: %s, Email: %s, Age: %d\n", u.ID, u.Name, u.Email, u.Age)
	}

	// 2. Get a specific user
	fmt.Println("\n2. Getting user by ID...")
	getResp, err := client.GetUser(ctx, &GetUserRequest{ID: 1})
	if err != nil {
		log.Fatal(err)
	}
	if getResp.Error != "" {
		fmt.Printf("   Error: %s\n", getResp.Error)
	} else {
		fmt.Printf("   User: %+v\n", getResp.User)
	}

	// 3. Create a new user
	fmt.Println("\n3. Creating new user...")
	createResp, err := client.CreateUser(ctx, &CreateUserRequest{
		Name:  "Charlie",
		Email: "charlie@example.com",
		Age:   24,
	})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("   Created user with ID: %d\n", createResp.ID)

	// 4. Update user
	fmt.Println("\n4. Updating user...")
	updateResp, err := client.UpdateUser(ctx, &UpdateUserRequest{
		ID:    1,
		Name:  "Alice Smith",
		Email: "alice.smith@example.com",
		Age:   29,
	})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("   Updated user: %+v\n", updateResp.User)

	// 5. Delete user
	fmt.Println("\n5. Deleting user...")
	deleteResp, err := client.DeleteUser(ctx, &DeleteUserRequest{ID: 3})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("   Success: %v, Message: %s\n", deleteResp.Success, deleteResp.Message)

	// 6. List users again
	fmt.Println("\n6. Listing users after operations...")
	listResp2, err := client.ListUsers(ctx, &ListUsersRequest{})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("   Total users: %d\n", len(listResp2.Users))

	fmt.Println("\n=== Demo completed successfully ===")

	time.Sleep(100 * time.Millisecond)
}

func init() {
	if os.Getenv("THRIFT_DEMO") == "" {
		log.Println(`
This is a demonstration file showing the structure of a Thrift client.

To run a complete Thrift example:

1. Install Thrift compiler:
   brew install thrift  # macOS
   or apt-get install thrift-compiler  # Ubuntu

2. Generate Go code:
   thrift --gen go idl/user.thrift

3. Update imports and use generated code:
   import "github.com/example/thrift/gen-go/user"

4. Create client:
   transport := thrift.NewTSocket("localhost:9090")
   protocol := thrift.NewTBinaryProtocolFactoryDefault().GetProtocol(transport)
   client := user.NewUserServiceClientFactory(transport, protocol)

5. Use client methods like:
   resp, err := client.GetUser(ctx, &user.GetUserRequest{Id: 1})
		`)
	}
}
