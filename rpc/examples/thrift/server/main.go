package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"sync"

	"git.apache.org/thrift.git/lib/go/thrift"
)

// Import generated code (after code generation)
// This is a placeholder - actual imports will be after running thrift code generation

// Mock types for demonstration (would be generated by thrift)
type User struct {
	ID    int32  `thrift:"id,1,required"`
	Name  string `thrift:"name,2,required"`
	Email string `thrift:"email,3,required"`
	Age   int32  `thrift:"age,4,required"`
}

type GetUserRequest struct {
	ID int32 `thrift:"id,1,required"`
}

type GetUserResponse struct {
	User  *User  `thrift:"user,1,required"`
	Error string `thrift:"error,2,optional"`
}

type CreateUserRequest struct {
	Name  string `thrift:"name,1,required"`
	Email string `thrift:"email,2,required"`
	Age   int32  `thrift:"age,3,required"`
}

type CreateUserResponse struct {
	ID    int32  `thrift:"id,1,required"`
	Error string `thrift:"error,2,optional"`
}

type ListUsersRequest struct{}

type ListUsersResponse struct {
	Users []*User `thrift:"users,1,required"`
	Error string  `thrift:"error,2,optional"`
}

type UpdateUserRequest struct {
	ID    int32  `thrift:"id,1,required"`
	Name  string `thrift:"name,2,optional"`
	Email string `thrift:"email,3,optional"`
	Age   int32  `thrift:"age,4,optional"`
}

type UpdateUserResponse struct {
	User  *User  `thrift:"user,1,required"`
	Error string `thrift:"error,2,optional"`
}

type DeleteUserRequest struct {
	ID int32 `thrift:"id,1,required"`
}

type DeleteUserResponse struct {
	Success bool   `thrift:"success,1,required"`
	Message string `thrift:"message,2,required"`
}

// UserServiceHandler implements the thrift service
type UserServiceHandler struct {
	mu     sync.RWMutex
	users  map[int32]*User
	nextID int32
}

func NewUserServiceHandler() *UserServiceHandler {
	h := &UserServiceHandler{
		users:  make(map[int32]*User),
		nextID: 1,
	}
	// Add initial users
	h.users[1] = &User{ID: 1, Name: "Alice", Email: "alice@example.com", Age: 28}
	h.users[2] = &User{ID: 2, Name: "Bob", Email: "bob@example.com", Age: 32}
	h.nextID = 3
	return h
}

func (h *UserServiceHandler) GetUser(ctx context.Context, req *GetUserRequest) (*GetUserResponse, error) {
	h.mu.RLock()
	defer h.mu.RUnlock()

	user, exists := h.users[req.ID]
	if !exists {
		return &GetUserResponse{Error: fmt.Sprintf("user with id %d not found", req.ID)}, nil
	}

	return &GetUserResponse{User: user}, nil
}

func (h *UserServiceHandler) CreateUser(ctx context.Context, req *CreateUserRequest) (*CreateUserResponse, error) {
	if req.Name == "" {
		return &CreateUserResponse{Error: "name is required"}, nil
	}
	if req.Email == "" {
		return &CreateUserResponse{Error: "email is required"}, nil
	}
	if req.Age <= 0 {
		return &CreateUserResponse{Error: "age must be positive"}, nil
	}

	h.mu.Lock()
	defer h.mu.Unlock()

	user := &User{
		ID:    h.nextID,
		Name:  req.Name,
		Email: req.Email,
		Age:   req.Age,
	}

	h.users[h.nextID] = user
	h.nextID++

	return &CreateUserResponse{ID: user.ID}, nil
}

func (h *UserServiceHandler) ListUsers(ctx context.Context, req *ListUsersRequest) (*ListUsersResponse, error) {
	h.mu.RLock()
	defer h.mu.RUnlock()

	users := make([]*User, 0, len(h.users))
	for _, user := range h.users {
		users = append(users, user)
	}

	return &ListUsersResponse{Users: users}, nil
}

func (h *UserServiceHandler) UpdateUser(ctx context.Context, req *UpdateUserRequest) (*UpdateUserResponse, error) {
	h.mu.Lock()
	defer h.mu.Unlock()

	user, exists := h.users[req.ID]
	if !exists {
		return &UpdateUserResponse{Error: fmt.Sprintf("user with id %d not found", req.ID)}, nil
	}

	if req.Name != "" {
		user.Name = req.Name
	}
	if req.Email != "" {
		user.Email = req.Email
	}
	if req.Age > 0 {
		user.Age = req.Age
	}

	return &UpdateUserResponse{User: user}, nil
}

func (h *UserServiceHandler) DeleteUser(ctx context.Context, req *DeleteUserRequest) (*DeleteUserResponse, error) {
	h.mu.Lock()
	defer h.mu.Unlock()

	if _, exists := h.users[req.ID]; !exists {
		return &DeleteUserResponse{
			Success: false,
			Message: fmt.Sprintf("user with id %d not found", req.ID),
		}, nil
	}

	delete(h.users, req.ID)

	return &DeleteUserResponse{
		Success: true,
		Message: "user deleted successfully",
	}, nil
}

// Simple Thrift processor (simplified for demonstration)
// In real usage, this would be generated by thrift compiler

func main() {
	// This is a simplified implementation showing the structure
	// In production, you would:
	// 1. Run: thrift --gen go idl/user.thrift
	// 2. Import the generated code
	// 3. Use the generated processor and server

	handler := NewUserServiceHandler()

	// For demonstration, we'll create a simple TCP server
	// In real usage, you'd use thrift.NewTSimpleServer, thrift.NewTThreadedServer, etc.

	listener, err := net.Listen("tcp", ":9090")
	if err != nil {
		log.Fatalf("Failed to listen: %v", err)
	}
	defer listener.Close()

	log.Println("Thrift server listening on :9090")
	log.Println("Note: This is a simplified demonstration.")
	log.Println("For full Thrift support, run: thrift --gen go idl/user.thrift")

	// Simple accept loop for demonstration
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("Accept error: %v", err)
			continue
		}

		log.Printf("New connection from %s", conn.RemoteAddr())
		conn.Close() // Close immediately in this demo

		// In real implementation:
		// transport := thrift.NewTTransportFactory().GetTransport(conn)
		// protocol := thrift.NewTBinaryProtocolFactoryDefault().GetProtocol(transport)
		// processor := user.NewUserServiceProcessor(handler)
		// processor.Process(processor, protocol)
	}
}

func init() {
	// This is a demonstration file
	// The actual implementation requires generated code from thrift compiler
	if os.Getenv("THRIFT_DEMO") == "" {
		log.Println(`
This is a demonstration file showing the structure of a Thrift server.

To run a complete Thrift example:

1. Install Thrift compiler:
   brew install thrift  # macOS

2. Generate Go code:
   thrift --gen go idl/user.thrift

3. Update imports and use generated code

4. Run:
   go run server/main.go

For now, this demonstrates the handler implementation pattern.
		`)
	}
}
