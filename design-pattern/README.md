# 设计模式学习

## 命令

``` bash
npm i -g zx
```

```bash
# builder 为建造者模式
yarn go --tag=builder
```

## doc

### 创建型模式

- 建造者模式
  - 意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
  - 主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
  - 何时使用：一些基本部件不会变，而其组合经常变化的时候。

- 工厂模式
  - 意图：其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型，工厂模式使其创建过程延迟到子类进行。
  - 主要解决：主要解决接口选择的问题。
  - 何时使用：我们明确地计划不同条件下创建不同实例时。

- 抽象工厂模式
  - 意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
  - 主要解决：主要解决接口选择的问题。
  - 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

- 原型模式 就是clone自己一下

### 结构型模式

- 装饰器模式
  - 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
  - 主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
  - 何时使用：在不想增加很多子类的情况下扩展类。

- 适配器模式
  - 意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
  - 主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
  - 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

[菜鸟教程 设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)

[装饰器](https://www.bookstack.cn/read/es6-3rd/spilt.2.docs-decorator.md)
